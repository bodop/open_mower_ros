--- a/src/mower_logic/src/mower_logic/mower_logic.cpp
+++ b/src/mower_logic/src/mower_logic/mower_logic.cpp
@@ -379,6 +379,8 @@ bool isGpsGood() {
 /// @brief Called every 0.5s, used to control BLADE motor via mower_enabled variable and stop any movement in case of /odom and /mower/status outages
 /// @param timer_event
 void checkSafety(const ros::TimerEvent &timer_event) {
+  static int gpsWasGood=1,gpsHadTimeout=0;
+
     const auto last_status = getStatus();
     const auto last_config = getConfig();
     const auto last_pose = getPose();
@@ -444,7 +446,13 @@ void checkSafety(const ros::TimerEvent &
         setLastGoodGPS(ros::Time::now());
         high_level_status.gps_quality_percent =
                 1.0 - fmin(1.0, last_pose.position_accuracy / last_config.max_position_accuracy);
-        ROS_INFO_STREAM_THROTTLE(10, "GPS quality: " << high_level_status.gps_quality_percent);
+        if (gpsWasGood) {
+          ROS_INFO_STREAM_THROTTLE(10, "GPS quality: " << high_level_status.gps_quality_percent);
+        } else {
+          gpsWasGood=1;
+          // Show Low quality GPS has ended with the same log level.
+          ROS_WARN_STREAM("GPS quality: " << high_level_status.gps_quality_percent);
+        }
     } else {
         // GPS = bad, set quality to 0
         high_level_status.gps_quality_percent = 0;
@@ -452,7 +460,10 @@ void checkSafety(const ros::TimerEvent &
             // set this if we don't even have an orientation
             high_level_status.gps_quality_percent = -1;
         }
-        ROS_WARN_STREAM_THROTTLE(1, "Low quality GPS");
+        if (gpsWasGood) {
+          ROS_WARN_STREAM("Low quality GPS");
+          gpsWasGood=0;
+        }
     }
 
     bool gpsTimeout = ros::Time::now() - last_good_gps > ros::Duration(last_config.gps_timeout);
@@ -460,7 +471,12 @@ void checkSafety(const ros::TimerEvent &
     if (gpsTimeout) {
         // GPS = bad, set quality to 0
         high_level_status.gps_quality_percent = 0;
-        ROS_WARN_STREAM_THROTTLE(1, "GPS timeout");
+        if (!gpsHadTimeout) {
+          gpsHadTimeout=1;
+          ROS_WARN_STREAM("GPS timeout");
+        }
+    } else {
+      gpsHadTimeout=0;
     }
 
     if (currentBehavior != nullptr && currentBehavior->needs_gps()) {
--- a/src/lib/xbot_monitoring/src/heatmap_generator.cpp
+++ b/src/lib/xbot_monitoring/src/heatmap_generator.cpp
@@ -35,16 +35,24 @@ void onMap(const xbot_msgs::Map &mapInfo
 }
 
 void onSensorData(const std::string sensor_id, const xbot_msgs::SensorDataDouble::ConstPtr &msg) {
+  static int hadError=0;
     auto & [map, publisher] = pubsub_map[sensor_id];
     try {
         map.atPosition("intensity",
                        grid_map::Position(last_pose.pose.pose.position.x, last_pose.pose.pose.position.y)) = msg->data;
         map.atPosition("elevation",
                        grid_map::Position(last_pose.pose.pose.position.x, last_pose.pose.pose.position.y)) = 0;
+        if (hadError) {
+          hadError=0;
+          ROS_WARN_STREAM("Point added to heatmap.");
+        }
     } catch (std::exception &e) {
         // error inserting into map, skip it
+      if (!hadError) {
+        hadError=1;
         ROS_WARN_STREAM("Could not add point to heatmap: " << e.what());
-        return;
+      }
+      return;
     }
 
     sensor_msgs::PointCloud2 mapmsg;
