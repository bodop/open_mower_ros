--- a/src/lib/ntrip_client/scripts/ntrip_ros.py
+++ b/src/lib/ntrip_client/scripts/ntrip_ros.py
@@ -116,11 +116,6 @@ class NTRIPRos:
     # Setup a shutdown hook
     rospy.on_shutdown(self.stop)
 
-    # Connect the client
-    if not self._client.connect():
-      rospy.logerr('Unable to connect to NTRIP server')
-      return 1
-
     # Setup our subscriber
     self._nmea_sub = rospy.Subscriber('nmea', Sentence, self.subscribe_nmea, queue_size=10)
 
@@ -141,9 +136,19 @@ class NTRIPRos:
 
   def subscribe_nmea(self, nmea):
     # Just extract the NMEA from the message, and send it right to the server
-    self._client.send_nmea(nmea.sentence)
+    if self._client._connected:
+      self._client.send_nmea(nmea.sentence)
 
   def publish_rtcm(self, event):
+    if self._rtcm_pub.get_num_connections()==0:
+      if self._client._connected:
+        self._client.disconnect()
+      return
+    if not self._client._connected:
+      # Connect the client
+      if not self._client.connect():
+        rospy.logerr('Unable to connect to NTRIP server')
+        return
     for raw_rtcm in self._client.recv_rtcm():
       self._rtcm_pub.publish(self._create_rtcm_message(raw_rtcm))
 
--- a/src/lib/xbot_driver_gps/src/driver_gps_node.cpp
+++ b/src/lib/xbot_driver_gps/src/driver_gps_node.cpp
@@ -24,6 +24,8 @@
 using namespace xbot::driver::gps;
 using namespace nmea;
 
+static ros::NodeHandle *n;
+
 ros::Publisher pose_pub;
 ros::Publisher xbot_pose_pub;
 ros::Publisher latency_pub1;
@@ -187,13 +189,27 @@ void convert_gps_result(const GpsInterfa
 }
 
 void gps_state_received(const GpsInterface::GpsState &state) {
-    // new state received, publish
-    convert_gps_result(state, pose_result);
+  static ros::Subscriber rtcm_sub;
+  static int rtcm_connected=0;
+  // new state received, publish
+  convert_gps_result(state, pose_result);
+  pose_pub.publish(pose_result.pose);
+
+  if (xbot_pose_pub.getNumSubscribers()>0) {
+    if (!rtcm_connected) {
+      rtcm_sub = n->subscribe("rtcm", 0, rtcm_received,
+                             ros::TransportHints().tcpNoDelay(true));
+      rtcm_connected=1;
+    }
     xbot_pose_pub.publish(pose_result);
-    pose_pub.publish(pose_result.pose);
-
     // send feedback to VRS
     generate_nmea(state.pos_lat, state.pos_lon);
+  } else {
+    if (rtcm_connected) {
+      rtcm_connected=0;
+      rtcm_sub.shutdown();
+    }
+  }
 }
 
 void
@@ -226,7 +242,7 @@ int main(int argc, char **argv) {
 
     ros::init(argc, argv, "xbot_driver_gps");
 
-    ros::NodeHandle n;
+    n=new ros::NodeHandle();
     ros::NodeHandle paramNh("~");
 
     isUbxInterface = paramNh.param("ubx_mode", true);
@@ -277,11 +293,8 @@ int main(int argc, char **argv) {
     // Subscribe to wheel ticks
     ros::Subscriber wheel_tick_sub = paramNh.subscribe("wheel_ticks", 0, wheel_tick_received,
                                                        ros::TransportHints().tcpNoDelay(true));
-    ros::Subscriber rtcm_sub = n.subscribe("rtcm", 0, rtcm_received,
-                                           ros::TransportHints().tcpNoDelay(true));
-
 
-    vrs_nmea_pub = n.advertise<nmea_msgs::Sentence>("/nmea", 10);
+    vrs_nmea_pub = n->advertise<nmea_msgs::Sentence>("/nmea", 10);
     pose_pub = paramNh.advertise<geometry_msgs::PoseWithCovariance>("pose", 10);
     xbot_pose_pub = paramNh.advertise<xbot_msgs::AbsolutePose>("xb_pose", 10);
     imu_pub = paramNh.advertise<sensor_msgs::Imu>("imu", 10);
--- a/src/lib/xbot_positioning/src/xbot_positioning.cpp
+++ b/src/lib/xbot_positioning/src/xbot_positioning.cpp
@@ -67,13 +67,13 @@ nav_msgs::Odometry odometry;
 xbot_positioning::KalmanState state_msg;
 xbot_msgs::AbsolutePose xb_absolute_pose_msg;
 
-bool gps_enabled = true;
 int gps_outlier_count = 0;
 int valid_gps_samples = 0;
 int gps_message_throttle=1;
 
 ros::Time last_gps_time(0.0);
 
+ros::NodeHandle *paramNh;
 
 void onImu(const sensor_msgs::Imu::ConstPtr &msg) {
     if(!has_gyro) {
@@ -160,7 +160,7 @@ void onImu(const sensor_msgs::Imu::Const
         xb_absolute_pose_msg.flags |= xbot_msgs::AbsolutePose::FLAG_SENSOR_FUSION_RECENT_ABSOLUTE_POSE;
     } else {
         // on GPS timeout, we set accuracy to 0.
-        xb_absolute_pose_msg.position_accuracy = 999;
+        xb_absolute_pose_msg.position_accuracy = 998;
     }
     // TODO: set real value
     xb_absolute_pose_msg.orientation_accuracy = 0.01;
@@ -199,11 +199,6 @@ void onWheelTicks(const xbot_msgs::Wheel
     last_ticks = *msg;
 }
 
-bool setGpsState(xbot_positioning::GPSControlSrvRequest &req, xbot_positioning::GPSControlSrvResponse &res) {
-    gps_enabled = req.gps_enabled;
-    return true;
-}
-
 bool setPose(xbot_positioning::SetPoseSrvRequest &req, xbot_positioning::SetPoseSrvResponse &res) {
     tf2::Quaternion q;
     tf2::fromMsg(req.robot_pose.orientation, q);
@@ -218,10 +213,6 @@ bool setPose(xbot_positioning::SetPoseSr
 }
 
 void onPose(const xbot_msgs::AbsolutePose::ConstPtr &msg) {
-    if(!gps_enabled) {        
-        ROS_INFO_STREAM_THROTTLE(gps_message_throttle, "dropping GPS update, since gps_enabled = false.");
-        return;
-    }
     // TODO fuse with high covariance?
     if((msg->flags & (xbot_msgs::AbsolutePose::FLAG_GPS_RTK_FIXED)) == 0) {
         ROS_INFO_STREAM_THROTTLE(1, "Dropped GPS update, since it's not RTK Fixed");
@@ -300,11 +291,27 @@ void onPose(const xbot_msgs::AbsolutePos
 
 }
 
+static void set_gps_state(bool enable) {
+  static bool gps_enabled=false;
+  static ros::Subscriber pose_sub;
+  if (enable!=gps_enabled) {
+    if ((gps_enabled=enable)) {
+      pose_sub=paramNh->subscribe("xb_pose_in", 10, onPose);
+    } else {
+      pose_sub.shutdown();
+    }
+  }
+}
+
+bool setGpsState(xbot_positioning::GPSControlSrvRequest &req, xbot_positioning::GPSControlSrvResponse &res) {
+  set_gps_state(req.gps_enabled);
+  return true;
+}
+
 int main(int argc, char **argv) {
     ros::init(argc, argv, "xbot_positioning");
 
     has_gps = false;
-    gps_enabled = true;
     vx = 0.0;
     has_gyro = false;
     has_ticks = false;
@@ -317,19 +324,19 @@ int main(int argc, char **argv) {
     antenna_offset_x = antenna_offset_y = 0;
 
     ros::NodeHandle n;
-    ros::NodeHandle paramNh("~");
+    paramNh=new ros::NodeHandle("~");
+
 
     ros::ServiceServer gps_service = n.advertiseService("xbot_positioning/set_gps_state", setGpsState);
     ros::ServiceServer pose_service = n.advertiseService("xbot_positioning/set_robot_pose", setPose);
 
-    paramNh.param("skip_gyro_calibration", skip_gyro_calibration, false);
-    paramNh.param("gyro_offset", gyro_offset, 0.0);
-    paramNh.param("min_speed", min_speed, 0.01);
-    paramNh.param("max_gps_accuracy", max_gps_accuracy, 0.1);
-    paramNh.param("debug", publish_debug, false);
-    paramNh.param("antenna_offset_x", antenna_offset_x, 0.0);
-    paramNh.param("antenna_offset_y", antenna_offset_y, 0.0);
-    paramNh.param("gps_message_throttle", gps_message_throttle, 1);    
+    paramNh->param("skip_gyro_calibration", skip_gyro_calibration, false);
+    paramNh->param("gyro_offset", gyro_offset, 0.0);
+    paramNh->param("min_speed", min_speed, 0.01);
+    paramNh->param("max_gps_accuracy", max_gps_accuracy, 0.1);
+    paramNh->param("debug", publish_debug, false);
+    paramNh->param("antenna_offset_x", antenna_offset_x, 0.0);
+    paramNh->param("antenna_offset_y", antenna_offset_y, 0.0);
 
     core.setAntennaOffset(antenna_offset_x, antenna_offset_y);
 
@@ -339,17 +346,18 @@ int main(int argc, char **argv) {
         ROS_WARN_STREAM("Using gyro offset of: " << gyro_offset);
     }
 
-    odometry_pub = paramNh.advertise<nav_msgs::Odometry>("odom_out", 50);
-    xbot_absolute_pose_pub = paramNh.advertise<xbot_msgs::AbsolutePose>("xb_pose_out", 50);
+    odometry_pub = paramNh->advertise<nav_msgs::Odometry>("odom_out", 50);
+    xbot_absolute_pose_pub = paramNh->advertise<xbot_msgs::AbsolutePose>("xb_pose_out", 50);
     if(publish_debug) {
-        dbg_expected_motion_vector = paramNh.advertise<geometry_msgs::Vector3>("debug_expected_motion_vector", 50);
-        kalman_state = paramNh.advertise<xbot_positioning::KalmanState>("kalman_state", 50);
+        dbg_expected_motion_vector = paramNh->advertise<geometry_msgs::Vector3>("debug_expected_motion_vector", 50);
+        kalman_state = paramNh->advertise<xbot_positioning::KalmanState>("kalman_state", 50);
     }
 
-    ros::Subscriber imu_sub = paramNh.subscribe("imu_in", 10, onImu);
-    ros::Subscriber pose_sub = paramNh.subscribe("xb_pose_in", 10, onPose);
-    ros::Subscriber wheel_tick_sub = paramNh.subscribe("wheel_ticks_in", 10, onWheelTicks);
+    ros::Subscriber imu_sub = paramNh->subscribe("imu_in", 10, onImu);
+    ros::Subscriber wheel_tick_sub = paramNh->subscribe("wheel_ticks_in", 10, onWheelTicks);
 
+    set_gps_state(true);
+    
     ros::spin();
     return 0;
 }
